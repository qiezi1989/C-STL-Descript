* C++中的容器类包括“顺序存储结构”和“关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。
若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。
  1. vector
    * 连续存储结构，每个元素在内存上是连续的；
    * 支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；
  2. deque
    * 连续存储结构，即其每个元素在内存上也是连续的，类似于vector，不同之处在于，deque提供了两级数组结构，第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。
    * 这样，deque除了具有vector的所有功能外，还支持高效的首端插入/删除操作。
  3. list
    * 非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。
    * 支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。
  4. vector V.S. list V.S. deque：
    1. 若需要随机访问操作，则选择vector；
    2. 若已经知道需要存储元素的数目， 则选择vector；
    3. 若需要随机插入/删除（不仅仅在两端），则选择list
    4. 只有需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector。
    5. 若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中。
    6. 当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。
  5. capacity V.S size
    1. capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。
    2. size是容器当前存储的元素的数目。
    3. vector默认的容量初始值，以及增长规则是依赖于编译器的。
  6. 用vector存储自定义类对象时，自定义类对象须满足：
    1. 有可供调用的无参构造函数（默认的或自定义的）；
    2. 有可用的拷贝赋值函数（默认的或自定义的）
  7. 迭代器iterator
    1. vector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。

* 以下为整个列表概述：

|标准容器类|说明|
|:-|:-|
|顺序性容器|
|vector|从后面快速的插入与删除，直接访问任何元素|
|deque|从前面或后面快速的插入与删除，直接访问任何元素|
|list|双链表，从任何地方快速插入与删除|
|关联容器|
|set|快速查找，不允许重复值|
|multiset|快速查找，允许重复值|
|map|一对多映射，基于关键字快速查找，不允许重复值|
|multimap|一对多映射，基于关键字快速查找，允许重复值
|容器适配器|
|stack|后进先出|
|queue|先进先出|
|priority_queue|最高优先级元素总是第一个出列|

* 所有标准库共有函数

|||
|:-|:-|
|默认构造函数|提供容器默认初始化的构造函数。|
|复制构造函数|将容器初始化为现有同类容器副本的构造函数|
|析构函数|不再需要容器时进行内存整理的析构函数|
|empty|容器中没有元素时返回true,否则返回false|
|max_size|返回容器中最大元素个数|
|size|返回容器中当前元素个数|
|operator=|将一个容器赋给另一个容器|
|operator<|如果第一个容器小于第二个容器，返回true，否则返回false，|
|operator<=|如果第一个容器小于或等于第二个容器，返回true，否则返回false|
|operator>|如果第一个容器大于第二个容器，返回true，否则返回false|
|operator>=|如果第一个容器大于或等于第二个容器，返回true，否则返回false|
|operator==|如果第一个容器等于第二个容器，返回true，否则返回false|
|operator!=|如果第一个容器不等于第二个容器，返回true，否则返回false|
|swap|交换两个容器的元素|

其中operator>,operator>=,operator<,operator<=,operator==,operator!=均不适用于priority_queue

* 顺序容器和关联容器共有函数

|||
|:-|:-|
|begin|该函数两个版本返回iterator或const_iterator，引用容器第一个元素|
|end|该函数两个版本返回iterator或const_iterator,引用容器最后一个元素后面一位|
|rbegin|该函数两个版本返回reverse_iterator或const_reverse_iterator,引用容器最后一个元素|
|rend|该函数两个版本返回reverse_iterator或const_reverse_iterator，引用容器第一个元素前面一位|
|erase|从容器中清除一个或几个元素|
|clear|清除容器中所有元素|

* 下表显示了顺序容器和关联容器中常用的typedef，这些typedef常用于变量、参数和函数返回值的一般性声明。
* 
|||
|:-|:-|
|value_type|容器中存放元素的类型|
|reference|容器中存放元素类型的引用|
|const_reference|容器中存放元素类型的常量引用，这种引用只能读取容器中的元素和进行const操作|
|pointer|容器中存放元素类型的指针|
|iterator|指向容器中存放元素类型的迭代器|
|const_iterator|指向容器中存放元素类型的常量迭代器，只能读取容器中的元素|
|reverse_iterator|指向容器中存放元素类型的逆向迭代器，这种迭代器在容器中逆向迭代|
|const_reverse_iterator|指向容器中存放元素类型的逆向迭代器，只能读取容器中的元素|
|difference_type|引用相同容器的两个迭代器相减结果的类型（list和关联容器没有定义operator-）|
|size_type|用于计算容器中项目数和检索顺序容器的类型（不能对list检索）|

 

* 序列类容器
	1. vector向量相当于一个数组
	在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacity（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。

   优点：1. 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()
   	2. 随机访问方便，即支持[ ]操作符和vector.at()
   	3. 节省空间。

   缺点：1. 在内部进行插入删除操作效率低。
   	2. 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。
   	3. 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放

* list 双向链表
	* 每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。

   优点：1. 不使用连续内存完成动态操作。
   	2. 在内部方便的进行插入和删除操作
   	3. 可在两端进行push、pop

   缺点：1. 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()
	2. 相对于verctor占用内存多

* deque 双端队列 double-end queue
	deque是在功能上合并了vector和list。

   优点：1. 随机访问方便，即支持[ ]操作符和vector.at()
	2. 在内部方便的进行插入和删除操作
	3. 可在两端进行push、pop

   缺点：1. 占用内存多

使用区别：

     1. 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
     2. 如果你需要大量的插入和删除，而不关心随机存取，则应使用list
     3. 如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque

test
